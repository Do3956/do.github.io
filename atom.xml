<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李庭嘉的博客</title>
  
  <subtitle>工具谁都能用，掌握原理才是核心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-20T05:39:33.407Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Do Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>读《人月神话》</title>
    <link href="http://yoursite.com/2019/01/20/%E8%AF%BB%E3%80%8A%E4%BA%BA%E6%9C%88%E7%A5%9E%E8%AF%9D%E3%80%8B/"/>
    <id>http://yoursite.com/2019/01/20/读《人月神话》/</id>
    <published>2019-01-20T04:02:41.000Z</published>
    <updated>2019-01-20T05:39:33.407Z</updated>
    
    <content type="html"><![CDATA[<p>列几个我觉得重要的部分：</p><ol><li><p>沟通成本，N人团队的两两组合沟通时间，我的理解是排列组合的 C(N) </p><blockquote><p>团队精简化，5-10人为一组，太多也管不过来。<br>如果要添加人手，在项目最初加入比中期加入效率高。<br>在发现项目进度延迟较大后，为了赶进度而加人手，往往没什么效果，反而会拖慢进度。</p></blockquote></li><li><p>权力下放</p><blockquote><p>不要过多插手下属的任务，每个人都需要自己的舞台和成就感，才能发挥最大的团队力量。</p></blockquote></li><li><p>信息隔离</p><blockquote><p>鉴于沟通成本，并非所有人都需要知道所有的事情。</p></blockquote></li><li><p>项目的进度 != 人*月</p><blockquote><p>由于沟通成本和软件的复杂度，团队进度排期 &gt;&gt; 个人小项目排期</p></blockquote></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;列几个我觉得重要的部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;沟通成本，N人团队的两两组合沟通时间，我的理解是排列组合的 C(N) &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;团队精简化，5-10人为一组，太多也管不过来。&lt;br&gt;如果要添加人手，在项目最初加入比中期加入效率高。&lt;
      
    
    </summary>
    
      <category term="读书笔记" scheme="http://yoursite.com/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="软件设计" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
      <category term="读书笔记" scheme="http://yoursite.com/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>所谓设计模式-六大原则</title>
    <link href="http://yoursite.com/2019/01/20/%E6%89%80%E8%B0%93%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99/"/>
    <id>http://yoursite.com/2019/01/20/所谓设计模式-六大原则/</id>
    <published>2019-01-20T02:02:41.000Z</published>
    <updated>2019-01-20T05:39:33.407Z</updated>
    
    <content type="html"><![CDATA[<p>总原则：开闭原则（Open Close Principle）<br>开闭原则就是说对扩展开放，对修改关闭。<br>在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。<br>所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。<br>想要达到这样的效果，我们需要使用接口和抽象类等，后面的具体设计中我们会提到这点。</p><p>1、单一职责原则<br>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，如若不然，就应该把类拆分。</p><p>2、里氏替换原则（Liskov Substitution Principle）<br>里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科</p><p>历史替换原则中，子类对父类的方法尽量不要重写和重载。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</p><p>3、依赖倒转原则（Dependence Inversion Principle）<br>这个是开闭原则的基础，具体内容：面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p><p>4、接口隔离原则（Interface Segregation Principle）<br>这个原则的意思是：每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p><p>5、迪米特法则（最少知道原则）（Demeter Principle）<br>就是说：一个类对自己依赖的类知道的越少越好。也就是说无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p><p>最少知道原则的另一个表达方式是：只与直接的朋友通信。类之间只要有耦合关系，就叫朋友关系。耦合分为依赖、关联、聚合、组合等。我们称出现为成员变量、方法参数、方法返回值中的类为直接朋友。局部变量、临时变量则不是直接的朋友。我们要求陌生的类不要作为局部变量出现在类中。</p><p>6、合成复用原则（Composite Reuse Principle）<br>原则是尽量首先使用合成/聚合的方式，而不是使用继承。</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.cnblogs.com/geek6/p/3951677.html" target="_blank" rel="noopener">https://www.cnblogs.com/geek6/p/3951677.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;总原则：开闭原则（Open Close Principle）&lt;br&gt;开闭原则就是说对扩展开放，对修改关闭。&lt;br&gt;在程序需要进行拓展的时候，不能去修改原有的代码，而是要扩展原有代码，实现一个热插拔的效果。&lt;br&gt;所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。&lt;b
      
    
    </summary>
    
      <category term="软件设计" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="软件设计" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>所谓设计模式</title>
    <link href="http://yoursite.com/2019/01/20/%E6%89%80%E8%B0%93%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/01/20/所谓设计模式/</id>
    <published>2019-01-20T02:02:41.000Z</published>
    <updated>2019-01-20T05:39:33.407Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>个人观点：对于 python 来说，它本来就是一个很灵活的语言，要想实现相应的功能，并不一定非得用这些设计模式的概念。<br>而且每个设计模式都有各自的使用场景和优缺点，正确理解，领悟各自的适用场景才是最重要的。</p></blockquote><h1 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h1><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>对于一个方法，需要在多种情景下调用。如发送消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class SendModule:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    发生消息的原型</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def send(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">class EMail(SendModule):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    具体的应用场景1</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def send(self):</span><br><span class="line">        print(&quot;通过邮件发送&quot;)</span><br><span class="line">        </span><br><span class="line">class SMS(SendModule):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    具体的应用场景2</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def send(self):</span><br><span class="line">        print(&quot;通过短信发送&quot;)</span><br><span class="line"></span><br><span class="line">class SendFactory:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    这里就是简单工厂的部分</span><br><span class="line">    在这里判断用哪个情景来发送消息</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def send(self, type):</span><br><span class="line">        if type == 1:</span><br><span class="line">            EMail().send()</span><br><span class="line">        else:</span><br><span class="line">            SMS().send()</span><br></pre></td></tr></table></figure></p><p>更实际的，直接将SendFactory用方法来封装。<br>这里只返回哪个类对象，send方法让具体的业务调用。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def sender_factory(type):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    这里就是简单工厂的部分</span><br><span class="line">    在这里判断用哪个情景来发送消息</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    def send(self):</span><br><span class="line">        if type == 1:</span><br><span class="line">            return EMail()</span><br><span class="line">        else:</span><br><span class="line">            return SMS()</span><br></pre></td></tr></table></figure></p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>不需要用 sender_factory 来选择用哪个情景，直接根据具体的业务场景来调用 EMail().send() / SMS().send()。<br>免去了改 sender_factory 逻辑的烦恼。<br>其实简单工厂和工厂，主要的核心还是在于有一个相同的方法send，分别用于多种类。</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>将组装的部分放在一个类里面，组成一个实体</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class 头:</span><br><span class="line">    pass</span><br><span class="line">class 身体:</span><br><span class="line">    pass</span><br><span class="line">class 肢体:</span><br><span class="line">    pass</span><br><span class="line"></span><br><span class="line">class 鸭子:</span><br><span class="line">    return 头() + 身体() + 肢体()</span><br></pre></td></tr></table></figure><h2 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h2><ul><li>参考 *</li></ul><ul><li><a href="https://www.cnblogs.com/geek6/p/3951677.html" target="_blank" rel="noopener">https://www.cnblogs.com/geek6/p/3951677.html</a></li><li>《精通python设计模式》</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;个人观点：对于 python 来说，它本来就是一个很灵活的语言，要想实现相应的功能，并不一定非得用这些设计模式的概念。&lt;br&gt;而且每个设计模式都有各自的使用场景和优缺点，正确理解，领悟各自的适用场景才是最重要的。&lt;/p&gt;
&lt;/blockquote&gt;
      
    
    </summary>
    
      <category term="软件设计" scheme="http://yoursite.com/categories/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
    
      <category term="软件设计" scheme="http://yoursite.com/tags/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>URL命名规范</title>
    <link href="http://yoursite.com/2018/12/25/%E5%85%B3%E4%BA%8E%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%E7%9A%84%E7%96%91%E9%97%AE/"/>
    <id>http://yoursite.com/2018/12/25/关于服务发现的疑问/</id>
    <published>2018-12-25T14:02:41.000Z</published>
    <updated>2019-01-20T05:39:33.407Z</updated>
    
    <content type="html"><![CDATA[<ol><li>数据更新机制，变更通知型还是client每次都主动获取？</li></ol><ol><li>变更通知的话，如何通知wsgi 管理的服务；每次请求获取不太显示，如数据库、redis配置</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;数据更新机制，变更通知型还是client每次都主动获取？&lt;/li&gt;
&lt;/ol&gt;
&lt;ol&gt;
&lt;li&gt;变更通知的话，如何通知wsgi 管理的服务；每次请求获取不太显示，如数据库、redis配置&lt;/li&gt;
&lt;/ol&gt;

      
    
    </summary>
    
      <category term="微服务" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="服务发现" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    
  </entry>
  
  <entry>
    <title>关于python的代码规范</title>
    <link href="http://yoursite.com/2018/12/25/%E5%85%B3%E4%BA%8Epython%E7%9A%84%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/12/25/关于python的代码规范/</id>
    <published>2018-12-25T14:02:41.000Z</published>
    <updated>2019-01-20T05:39:33.407Z</updated>
    
    <content type="html"><![CDATA[<p>为了代码的易读性，方便团队多人协作，请大家统一按此标准去规范自己的代码。</p><h2 id="PEP8"><a href="#PEP8" class="headerlink" title="PEP8"></a>PEP8</h2><p>PEP8是 python 的代码规范标准，具体细节参考下面链接，在此不多叙述。</p><ul><li>原文 <a href="https://www.python.org/dev/peps/pep-0008/" target="_blank" rel="noopener">https://www.python.org/dev/peps/pep-0008/</a></li><li>中文翻译 <a href="https://blog.csdn.net/ratsniper/article/details/78954852" target="_blank" rel="noopener">https://blog.csdn.net/ratsniper/article/details/78954852</a></li></ul><p>可以用一些工具，如<code>atuopep8</code>去做辅助校验。</p><h2 id="保持代码简洁"><a href="#保持代码简洁" class="headerlink" title="保持代码简洁"></a>保持代码简洁</h2><p>不用的代码，不管是废弃的功能，还是未来有用，但目前用不上的，都删除。<br>如果需要，再从git版本记录中找回。<br>lib中的统一工具除外。</p><h2 id="内部命名规范"><a href="#内部命名规范" class="headerlink" title="内部命名规范"></a>内部命名规范</h2><ul><li>数量 count</li><li>开始时间 begin_time</li><li>结束时间 end_time</li><li>分页，起始值 offset，数量 limit</li><li>关键字查找，参数为q，代码中的变量为key_word</li></ul><h2 id="sql语句"><a href="#sql语句" class="headerlink" title="sql语句"></a>sql语句</h2><p>sql语句被包装成字符串，一般工具无法对此进行格式化校验，但仍需遵循以下规则：</p><h3 id="关键字大写"><a href="#关键字大写" class="headerlink" title="关键字大写"></a>关键字大写</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select id,name from test_barrage where id = 3;</span><br></pre></td></tr></table></figure><p>修正为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name FROM test_barrage WHERE id = 3;</span><br></pre></td></tr></table></figure><h3 id="缩进"><a href="#缩进" class="headerlink" title="缩进"></a>缩进</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name FROM test_barrage WHERE id = 3 and type=2 ORDER BY id;</span><br></pre></td></tr></table></figure><p>错误点：</p><ol><li><code>type=2</code>空格前后应有空格<code>type = 2</code></li><li>sql语句过长，<code>SELECT</code>、<code>WHERE</code>、<code>ORDER BY</code> 需要一行一个</li><li><code>WHERE</code>条件一行一个</li></ol><p>修正为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name FROM test_barrage </span><br><span class="line">WHERE id = 3 </span><br><span class="line">    and type=2 </span><br><span class="line">ORDER BY id;</span><br></pre></td></tr></table></figure><h3 id="慎用"><a href="#慎用" class="headerlink" title="慎用*"></a>慎用*</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from test_barrage where id = 3;</span><br></pre></td></tr></table></figure><p>如果不是必要，修正为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT id,name FROM test_barrage WHERE id = 3;</span><br></pre></td></tr></table></figure><h3 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h3><p>为了防止sql注入，pymysql提供了两种参数校验方式</p><ol><li><p>列表传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql = &quot;SELECT `id`, `password` </span><br><span class="line">        FROM `users` </span><br><span class="line">        WHERE `email`=%s&quot;</span><br><span class="line">cursor.execute(sql, [&apos;webmaster@python.org&apos;])</span><br></pre></td></tr></table></figure></li><li><p>字典传参</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sql = &quot;SELECT `id`, `password` </span><br><span class="line">        FROM `users` </span><br><span class="line">        WHERE `email`=%(email)s&quot;</span><br><span class="line">cursor.execute(sql, &#123;&quot;email&quot;:&apos;webmaster@python.org&apos;&#125;)</span><br></pre></td></tr></table></figure></li></ol><p>第一种比较容易出错，统一采用第二种</p><h2 id="pylint"><a href="#pylint" class="headerlink" title="pylint"></a>pylint</h2><p>代码提交前用 pylint 进行对代码规范进行打分，9.5以上方为合格。具体使用方法请参考：</p><ul><li><a href="https://pypi.org/project/pylint/" target="_blank" rel="noopener">https://pypi.org/project/pylint/</a></li><li><a href="https://www.cnblogs.com/zhangningyang/p/8652941.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhangningyang/p/8652941.html</a></li><li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-pylint/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/linux/l-cn-pylint/index.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;为了代码的易读性，方便团队多人协作，请大家统一按此标准去规范自己的代码。&lt;/p&gt;
&lt;h2 id=&quot;PEP8&quot;&gt;&lt;a href=&quot;#PEP8&quot; class=&quot;headerlink&quot; title=&quot;PEP8&quot;&gt;&lt;/a&gt;PEP8&lt;/h2&gt;&lt;p&gt;PEP8是 python 的代码规范
      
    
    </summary>
    
      <category term="代码规范" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="代码规范" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>URL命名规范</title>
    <link href="http://yoursite.com/2018/12/25/URL%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/12/25/URL命名规范/</id>
    <published>2018-12-25T14:02:41.000Z</published>
    <updated>2019-01-20T05:39:33.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="请求方式"><a href="#请求方式" class="headerlink" title="请求方式"></a>请求方式</h2><p>项目中统一只采用 get、post 两种方式</p><h3 id="get-查询请求"><a href="#get-查询请求" class="headerlink" title="get: 查询请求"></a>get: 查询请求</h3><p>参数不通过body，直接在放在URL上</p><h3 id="post-涉及修改数据的请求"><a href="#post-涉及修改数据的请求" class="headerlink" title="post: 涉及修改数据的请求"></a>post: 涉及修改数据的请求</h3><p>参数采用json格式，但URL也放上向get请求一样放上参数，用于请求日志查看、数据分析</p><h2 id="URL拼接方式"><a href="#URL拼接方式" class="headerlink" title="URL拼接方式"></a>URL拼接方式</h2><h3 id="业务统一"><a href="#业务统一" class="headerlink" title="业务统一"></a>业务统一</h3><p>第一个字符串代表具体的业务，如:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/login/user/&lt;int:user_id&gt;</span><br><span class="line">/login/user/&lt;str:user_name&gt;</span><br><span class="line">/login/user/&lt;int:phone&gt;</span><br></pre></td></tr></table></figure></p><p>login代表用户登陆的一系列请求。<br>这样做的好处一是统计的时候方便查看，二是万一要对某项业务做限制处理，只要用/login/去匹配就行。</p><h3 id="内部统一"><a href="#内部统一" class="headerlink" title="内部统一"></a>内部统一</h3><h4 id="根据内容查找弹幕"><a href="#根据内容查找弹幕" class="headerlink" title="根据内容查找弹幕"></a>根据内容查找弹幕</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`GET /barrage/lectures/get_barrages_by_content`</span><br></pre></td></tr></table></figure><p>查找统一用search，需要查找的关键词用q作为参数传递<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`GET /barrage/lectures/search`</span><br></pre></td></tr></table></figure></p><p>加上参数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`/barrage/lectures/search?q=a`</span><br></pre></td></tr></table></figure></p><h4 id="获取弹幕数量"><a href="#获取弹幕数量" class="headerlink" title="获取弹幕数量"></a>获取弹幕数量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`GET /barrage/lectures/barrage_num`</span><br></pre></td></tr></table></figure><p>数量统一用count表示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`GET /barrage/lectures/barrage_count`</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;请求方式&quot;&gt;&lt;a href=&quot;#请求方式&quot; class=&quot;headerlink&quot; title=&quot;请求方式&quot;&gt;&lt;/a&gt;请求方式&lt;/h2&gt;&lt;p&gt;项目中统一只采用 get、post 两种方式&lt;/p&gt;
&lt;h3 id=&quot;get-查询请求&quot;&gt;&lt;a href=&quot;#get-查询请
      
    
    </summary>
    
      <category term="代码规范" scheme="http://yoursite.com/categories/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
    
      <category term="代码规范" scheme="http://yoursite.com/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    
  </entry>
  
  <entry>
    <title>关于过进程的配置管理</title>
    <link href="http://yoursite.com/2018/12/20/flask%E5%88%B7%E6%96%B0%E5%86%85%E5%AD%98%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2018/12/20/flask刷新内存配置/</id>
    <published>2018-12-20T14:02:41.000Z</published>
    <updated>2019-01-20T05:39:33.373Z</updated>
    
    <content type="html"><![CDATA[<h4 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h4><p>程序中的配置，怎么能够实时更新。<br>其实我想解决的是业务配置的管理，可是想一想，无论业务配置还是服务的配置，<br>其本质也还都配置的管理，都可以参考服务发现那套逻辑。</p><h4 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h4><ol><li>对外暴露一个接口，用于刷新配置</li><li>定时加载配置到服务中</li><li>每次接口调用都实时去加载配置</li></ol><h4 id="各方案优缺点"><a href="#各方案优缺点" class="headerlink" title="各方案优缺点"></a>各方案优缺点</h4><ol><li>对外暴露一个接口，用于刷新配置<ol><li>稍微麻烦：要写接口，还要让对方调用，如果有多个进程，需要多次调用。</li></ol></li><li>定时加载配置到服务中 <ol><li>需要等待刷新的时间，配置人员要等待，不具备实时性</li><li>无法很好的把控程序刷新时机，如果要同时改多个配置，可能会有配置改到一半就被刷新的风险</li></ol></li><li>每次接口调用都实时去加载配置<ol><li>简单，但是配置多或访问量大的情况不适合</li><li>优化，将配置更新时间存在redis中，每次访问redis，和本地的更新时间做比较，不一致则更新。</li></ol></li></ol><blockquote><p>目前服务发现更多采用的是分布式k/v，直接用redis还是少数，这里只是简单列举思路</p></blockquote><h4 id="以往的方案"><a href="#以往的方案" class="headerlink" title="以往的方案"></a>以往的方案</h4><p>采用第一种。<br>用的twisted或tornado异步处理请求，每个进程分别对应两个端口，分别对内和对外提供服务。<br>对内服务主要用于刷新配置和设置临时变量。<br>如果要刷新配置，只要调用对应的内部端口即可。</p><h4 id="新的问题"><a href="#新的问题" class="headerlink" title="新的问题"></a>新的问题</h4><p>目前团队用的flask，采用wsgi管理多个进程，而多个进程的端口都是同一个。<br>怎么样才能让所有的进程都同步到最新的配置呢？</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://www.jianshu.com/p/75e1107530b1" target="_blank" rel="noopener">https://www.jianshu.com/p/75e1107530b1</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;需求：&quot;&gt;&lt;a href=&quot;#需求：&quot; class=&quot;headerlink&quot; title=&quot;需求：&quot;&gt;&lt;/a&gt;需求：&lt;/h4&gt;&lt;p&gt;程序中的配置，怎么能够实时更新。&lt;br&gt;其实我想解决的是业务配置的管理，可是想一想，无论业务配置还是服务的配置，&lt;br&gt;其本质也还都
      
    
    </summary>
    
      <category term="服务发现" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    
    
      <category term="服务发现" scheme="http://yoursite.com/tags/%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0/"/>
    
      <category term="wsgi" scheme="http://yoursite.com/tags/wsgi/"/>
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>git多人协作流程</title>
    <link href="http://yoursite.com/2018/12/20/git%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E6%B5%81%E7%A8%8B/"/>
    <id>http://yoursite.com/2018/12/20/git多人协作流程/</id>
    <published>2018-12-20T14:02:41.000Z</published>
    <updated>2019-01-20T05:39:33.377Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>git是一个管理代码的工具，具体的介绍及使用方法可以查看下面链接，在此不做叙述。</p><ul><li><a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001373962845513aefd77a99f4145f0a2c7a7ca057e7570000</a></li></ul><p>本文主要讲述团队协作中，git的使用流程。</p></blockquote><h2 id="1-每做一个新功能时，先从master拉一个新分支"><a href="#1-每做一个新功能时，先从master拉一个新分支" class="headerlink" title="1. 每做一个新功能时，先从master拉一个新分支"></a>1. 每做一个新功能时，先从master拉一个新分支</h2><p><code>git checkout -b 你的名字/功能名称</code> 如 <code>git checkout -b ltj/test_git_add_branch</code></p><h2 id="2-功能开发…提交代码到本地分支"><a href="#2-功能开发…提交代码到本地分支" class="headerlink" title="2. 功能开发…提交代码到本地分支"></a>2. 功能开发…提交代码到本地分支</h2><h2 id="3-上传本地分支到远程分支"><a href="#3-上传本地分支到远程分支" class="headerlink" title="3. 上传本地分支到远程分支"></a>3. 上传本地分支到远程分支</h2><p><code>git push origin ltj/test_git_add_branch remotes/origin/ltj/test_git_add_branch</code></p><h2 id="4-rebase，和master代码同步"><a href="#4-rebase，和master代码同步" class="headerlink" title="4. rebase，和master代码同步"></a>4. rebase，和master代码同步</h2><p>（相当于把master合并到当前分支，但更友好）<br><code>git fetch</code></p><p><code>git rebase origin/master</code></p><p>如果有冲突，需要解决冲突，提交，之后再继续rebase</p><p><code>git add .  ; git rebase --continue</code></p><p>这个过程一直持续循环到没有冲突为止</p><p>将rebase后的代码推送到远程分支</p><p><code>git push origin ltj/test_git_add_branch</code></p><p>如果rebase一直报错，可以强行推送到远程，但不建议用</p><p><code>git push origin ltj/test_git_add_branch -f</code></p><h2 id="5-发出合并请求，等master合并该分支"><a href="#5-发出合并请求，等master合并该分支" class="headerlink" title="5. 发出合并请求，等master合并该分支"></a>5. 发出合并请求，等master合并该分支</h2><p>到gitlab上进行页面操作</p><h2 id="6-过一段时间确认无误后"><a href="#6-过一段时间确认无误后" class="headerlink" title="6. 过一段时间确认无误后"></a>6. 过一段时间确认无误后</h2><p>删除远程分支<br><code>git push origin --delete ltj/test_git_add_branch</code></p><p>删除本地分支<br><code>git branch -D ltj/fix_paging</code></p><h2 id="可能遇到的问题："><a href="#可能遇到的问题：" class="headerlink" title="可能遇到的问题："></a>可能遇到的问题：</h2><ul><li>合并冲突 <a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840202368c74be33fbd884e71b570f2cc3c0d1dcf000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/001375840202368c74be33fbd884e71b570f2cc3c0d1dcf000</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;git是一个管理代码的工具，具体的介绍及使用方法可以查看下面链接，在此不做叙述。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.liaoxuefeng.com/wiki/0013739516305929606dd1836124
      
    
    </summary>
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>聊一聊flask的get</title>
    <link href="http://yoursite.com/2018/12/20/%E8%81%8A%E4%B8%80%E8%81%8Aflask%E7%9A%84get/"/>
    <id>http://yoursite.com/2018/12/20/聊一聊flask的get/</id>
    <published>2018-12-20T14:02:41.000Z</published>
    <updated>2019-01-20T05:39:33.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="获取参数的方式"><a href="#获取参数的方式" class="headerlink" title="获取参数的方式"></a>获取参数的方式</h2><h4 id="1-通过的URL获取，如：zoo-id，cat-id"><a href="#1-通过的URL获取，如：zoo-id，cat-id" class="headerlink" title="1. 通过的URL获取，如：zoo_id，cat_id"></a>1. 通过的URL获取，如：zoo_id，cat_id</h4><h4 id="2-通过-request-args-get-获取，如：name"><a href="#2-通过-request-args-get-获取，如：name" class="headerlink" title="2. 通过 request.args.get 获取，如：name"></a>2. 通过 request.args.get 获取，如：name</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">@BP.route(&apos;/zoo/&lt;int:zoo_id&gt;/cat/&lt;int:cat_id&gt;&apos;, methods=[&apos;GET&apos;])</span><br><span class="line">def get_cat_info(zoo_id, cat_id):</span><br><span class="line">    &quot;&quot;&quot;  &quot;&quot;&quot;</span><br><span class="line">    name = request.args.get(&apos;name&apos;, type=str, default=None)</span><br></pre></td></tr></table></figure><h2 id="get-获取json格式"><a href="#get-获取json格式" class="headerlink" title="get 获取json格式"></a>get 获取json格式</h2><h4 id="1-通过URL传递"><a href="#1-通过URL传递" class="headerlink" title="1. 通过URL传递"></a>1. 通过URL传递</h4><p>这种方法虽然比较麻烦，但是接口较为通用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@BP.route(&apos;/zoo/&lt;int:zoo_id&gt;/cats&apos;, methods=[&apos;GET&apos;])</span><br><span class="line">def get_cat_list(zoo_id):</span><br><span class="line">    &quot;&quot;&quot;  &quot;&quot;&quot;</span><br><span class="line">ids = request.args.get(&apos;ids&apos;, type=str, default=0)</span><br><span class="line">ids = json.loads(ids)</span><br></pre></td></tr></table></figure></p><p>测试方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = &apos;/zoo/&lt;int:zoo_id&gt;/cats?ids=%s&apos; % json.dumps([1,2,3])</span><br><span class="line">request.get(url)</span><br></pre></td></tr></table></figure></p><h4 id="2-通过body传递"><a href="#2-通过body传递" class="headerlink" title="2. 通过body传递"></a>2. 通过body传递</h4><p>get_json比较简单，获取到的已经是json格式了，可以直接使用。<br>但get一般都不会通过body来传参，非一般规范，可以和项目协商后，统一采用一种方式。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@BP.route(&apos;/zoo/&lt;int:zoo_id&gt;/cats&apos;, methods=[&apos;GET&apos;])</span><br><span class="line">def get_cat_list(zoo_id):</span><br><span class="line">params = request.get_json()</span><br><span class="line">id = params.get(&quot;id&quot;)</span><br></pre></td></tr></table></figure></p><p>测试方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url = &apos;/zoo/&lt;int:zoo_id&gt;/cats&apos;</span><br><span class="line">request.get(url, json=&#123;&quot;ids&quot;:[20]&#125;)</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;获取参数的方式&quot;&gt;&lt;a href=&quot;#获取参数的方式&quot; class=&quot;headerlink&quot; title=&quot;获取参数的方式&quot;&gt;&lt;/a&gt;获取参数的方式&lt;/h2&gt;&lt;h4 id=&quot;1-通过的URL获取，如：zoo-id，cat-id&quot;&gt;&lt;a href=&quot;#1-通过的UR
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
      <category term="flask" scheme="http://yoursite.com/categories/Python/flask/"/>
    
    
      <category term="flask" scheme="http://yoursite.com/tags/flask/"/>
    
  </entry>
  
  <entry>
    <title>Python的with原理</title>
    <link href="http://yoursite.com/2018/12/03/Python%E7%9A%84with%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/03/Python的with原理/</id>
    <published>2018-12-03T09:02:41.000Z</published>
    <updated>2019-01-20T05:39:33.373Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>对一个文件进行操作，我们可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(file, mode)</span><br><span class="line">...</span><br><span class="line">f.close() #关闭文件</span><br></pre></td></tr></table></figure></p><p>但是可能会在文件操作的过程中触发异常，导致<code>f.close()</code>没有被执行，于是我们对其做出以下改良：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = open(file, mode)</span><br><span class="line">try:</span><br><span class="line">    ...</span><br><span class="line">finally:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure></p><p>嗯…貌似有点繁琐，能不能用一个简单点的方法呢？这时<code>with</code>就出现了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(file, mode) as f:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><p>相当于用with包裹后，自动处理了文件的关闭。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>那具体是怎么实现的呢？<br>我们先来看看有关上下文管理器的概念：</p><ul><li><p>上下文管理协议（Context Management Protocol）</p><blockquote><p>包含方法 <strong>enter</strong>() 和 <strong>exit</strong>()，支持<br>该协议的对象要实现这两个方法。</p></blockquote></li><li><p>上下文管理器（Context Manager）</p><blockquote><p>支持上下文管理协议的对象，这种对象实现了<br><strong>enter</strong>() 和 <strong>exit</strong>() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，<br>负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，<br>也可以通过直接调用其方法来使用。</p></blockquote></li><li><p>运行时上下文（runtime context）</p><blockquote><p>由上下文管理器创建，通过上下文管理器的 <strong>enter</strong>() 和<br><strong>exit</strong>() 方法实现，<strong>enter</strong>() 方法在语句体执行之前进入运行时上下文，<strong>exit</strong>() 在<br>语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。</p></blockquote></li></ul><h3 id="with-语句执行过程"><a href="#with-语句执行过程" class="headerlink" title="with 语句执行过程"></a>with 语句执行过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">context_manager = context_expression</span><br><span class="line">exit = type(context_manager).__exit__ </span><br><span class="line">value = type(context_manager).__enter__(context_manager)</span><br><span class="line">exc = True   # True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理</span><br><span class="line">try:</span><br><span class="line">    try:</span><br><span class="line">        target = value  # 如果使用了 as 子句</span><br><span class="line">        with-body     # 执行 with-body</span><br><span class="line">    except:</span><br><span class="line">        # 执行过程中有异常发生</span><br><span class="line">        exc = False</span><br><span class="line">        # 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常</span><br><span class="line">        # 由外层代码对异常进行处理</span><br><span class="line">        if not exit(context_manager, *sys.exc_info()):</span><br><span class="line">            raise</span><br><span class="line">finally:</span><br><span class="line">    # 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出</span><br><span class="line">    # 或者忽略异常退出</span><br><span class="line">    if exc:</span><br><span class="line">        exit(context_manager, None, None, None)</span><br><span class="line">    # 缺省返回 None，None 在布尔上下文中看做是 False</span><br></pre></td></tr></table></figure><h3 id="自定义上下文管理器"><a href="#自定义上下文管理器" class="headerlink" title="自定义上下文管理器"></a>自定义上下文管理器</h3><p>现在试着自己实现一个上下文管理器，实现对文件资源的释放<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># 自行定義 Context Manager</span><br><span class="line">class File(object):</span><br><span class="line">  def __init__(self, filename, mode):</span><br><span class="line">    # 設定檔名與開檔模式</span><br><span class="line">    self.filename = filename</span><br><span class="line">    self.mode = mode</span><br><span class="line"></span><br><span class="line">  # 配給資源（開啟檔案）</span><br><span class="line">  def __enter__(self):</span><br><span class="line">    print(&quot;開啟檔案：&quot; + self.filename)</span><br><span class="line">    self.open_file = open(self.filename, self.mode)</span><br><span class="line">    return self.open_file</span><br><span class="line"></span><br><span class="line">  # 回收資源（關閉檔案）</span><br><span class="line">  def __exit__(self, type, value, traceback):</span><br><span class="line">    print(&quot;關閉檔案：&quot; + self.filename)</span><br><span class="line">    self.open_file.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with File(&quot;file.txt&quot;, &quot;w&quot;) as f:</span><br><span class="line">  print(&quot;寫入檔案...&quot;)</span><br><span class="line">  f.write(&quot;Hello, world.&quot;)</span><br></pre></td></tr></table></figure></p><p>另一种实现方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from contextlib import contextmanager</span><br><span class="line"></span><br><span class="line"># 自行定義 Context Manager</span><br><span class="line">@contextmanager</span><br><span class="line">def open_file(name, mode):</span><br><span class="line">  # 配給資源（開啟檔案）</span><br><span class="line">  f = open(name, mode)</span><br><span class="line">  yield f</span><br><span class="line">  # 回收資源（關閉檔案）</span><br><span class="line">  f.close()</span><br><span class="line"></span><br><span class="line">with open_file(&apos;file.txt&apos;, &apos;w&apos;) as f:</span><br><span class="line">  f.write(&quot;Hello, world.&quot;)</span><br></pre></td></tr></table></figure></p><h3 id="对with的总结"><a href="#对with的总结" class="headerlink" title="对with的总结"></a>对with的总结</h3><blockquote><p>with适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</p></blockquote><h3 id="nested-同时使用多个with嵌套"><a href="#nested-同时使用多个with嵌套" class="headerlink" title="nested 同时使用多个with嵌套"></a>nested 同时使用多个with嵌套</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with nested(A(), B(), C()) as (X, Y, Z):</span><br><span class="line">     # with-body code here</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with A() as X:</span><br><span class="line">    with B() as Y:</span><br><span class="line">        with C() as Z:</span><br><span class="line">             # with-body code here</span><br></pre></td></tr></table></figure><p>需要注意的是，发生异常后，如果某个上下文管理器的 <strong>exit</strong>() 方法对异常处理返回 False，则更外层的上下文管理器不会监测到异常。</p><p>参考</p><ul><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/index.html</a></li><li><a href="https://blog.gtwang.org/programming/python-with-context-manager-tutorial/" target="_blank" rel="noopener">https://blog.gtwang.org/programming/python-with-context-manager-tutorial/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;对一个文件进行操作，我们可以这样写：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>nginx频率限制模块之HttpLimitReqModul</title>
    <link href="http://yoursite.com/2018/11/30/nginx%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6%E6%A8%A1%E5%9D%97%E4%B9%8BHttpLimitReqModul/"/>
    <id>http://yoursite.com/2018/11/30/nginx频率限制模块之HttpLimitReqModul/</id>
    <published>2018-11-30T04:26:41.000Z</published>
    <updated>2018-12-03T11:21:15.448Z</updated>
    
    <content type="html"><![CDATA[<p>HttpLimitReqModul为nginx官方自带的<strong>限制单位时间内请求次数</strong>的功能模块，通过<strong>limit_req_zone</strong>和<strong>limit_req</strong>指令配合使用来达到限制。一旦对应的累计连接超过指定数量，就会返回503错误。<br>可以利用该规则对IP和URL进行访问频率的限制。</p><blockquote><ul><li>limit_conn_zone 定义IP或url访问的频率限制规则<br>只能配置在 http{} </li><li>limit_conn 启用对应的规则<br>可以配置于http{}，server{}，location{} </li></ul></blockquote><h4 id="限制规则"><a href="#限制规则" class="headerlink" title="限制规则"></a>限制规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone=ip_second:10m   rate=10r/s;</span><br><span class="line">limit_req_zone $request_uri zone=url_minute:10m   rate=1r/m;</span><br></pre></td></tr></table></figure><ul><li>limit_req_zone 可以理解为命令声明，类似于 <code>int x=0</code> 中的 int<h5 id="限制类型"><a href="#限制类型" class="headerlink" title="限制类型"></a>限制类型</h5></li><li>$binary_remote_addr 代表限制IP</li><li>$request_uri 代表限制URL<h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5></li><li><code>zone=ip_second:10m   rate=10r/s</code>相当于<code>zone=限制规则变量名:内存占用上限 频率=次数r/秒</code><h5 id="内存占用上限"><a href="#内存占用上限" class="headerlink" title="内存占用上限"></a>内存占用上限</h5></li><li>1m大约可以存1.6W个ip回话</li><li>10m—-16W<h5 id="频率限制"><a href="#频率限制" class="headerlink" title="频率限制"></a>频率限制</h5>采用漏桶原理，简单理解就是，<code>rate=10r/s</code> 这十个请求平均分配在1秒内，也就是100ms最多能通过一次请求，而不是前面100ms接收10次，后面才不能接收。</li></ul><h4 id="限制范围"><a href="#限制范围" class="headerlink" title="限制范围"></a>限制范围</h4><p>当 limit_req 设置后，对应的 limit_req_zone 规则才会生效，而且只在 limit_req 声明的范围内生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit_req   zone=限制规则变量名 burst=5  nodelay;</span><br></pre></td></tr></table></figure></p><h5 id="全局生效"><a href="#全局生效" class="headerlink" title="全局生效"></a>全局生效</h5><p>将此命令放在 http{} 层，紧接着 limit_req_zone 之后</p><h5 id="局部生效"><a href="#局部生效" class="headerlink" title="局部生效"></a>局部生效</h5><p>将此命令放在 server{} 或 location{} 层，则在此之外的层级不受影响，还可以在不同的层级设置不同的规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">limit_req   zone=限制规则变量名  burst=2  nodelay;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">limit_req   zone=限制规则变量名  burst=5  nodelay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="burst"><a href="#burst" class="headerlink" title="burst"></a>burst</h5><p>burst 代表令牌数量，至少要为1，即可以在limit_req_zone规则的基础上，额外可以请求的数量。<br>令牌消耗后，以 limit_req_zone 定义的时间单位恢复。</p><h4 id="频率单位"><a href="#频率单位" class="headerlink" title="频率单位"></a>频率单位</h4><p>只能控制 秒（rate=100r/s） 和 分钟（rate=100r/m） 级别</p><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p>多个限制时，只要有一个符合条件，就会触发限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">        #限制ip</span><br><span class="line">        limit_req_zone $binary_remote_addr zone=ip_second:10m   rate=10r/s;</span><br><span class="line">        limit_req   zone=ip_second  burst=5  nodelay;</span><br><span class="line">        limit_req_zone $binary_remote_addr zone=ip_minute:100m   rate=10r/m;</span><br><span class="line">        limit_req   zone=ip_minute  burst=50  nodelay;</span><br><span class="line"></span><br><span class="line">        #限制url</span><br><span class="line">        limit_req_zone $request_uri zone=url_minute:10m   rate=1r/m;</span><br><span class="line">        limit_req   zone=url_minute  burst=1  nodelay;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一秒内请求100次</p><blockquote><p>ab -n 100 -c 10 url</p></blockquote><p>只会有51个成功，<code>rate=10r/m</code>代表一分钟10个请求，系统会默认把这十个请求平均分配在60秒内，即6秒一个请求，所以1秒内，只能用掉这里的1个名额，剩下50个名额用的是<code>burst=50</code>令牌的名额。</p><h4 id="自定义返回码"><a href="#自定义返回码" class="headerlink" title="自定义返回码"></a>自定义返回码</h4><p>自定义限制规则生效后的返回码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_conn_status 503;</span><br><span class="line"></span><br><span class="line">    limit_req_zone $binary_remote_addr zone=ip_second:10m   rate=100r/s;</span><br><span class="line">    limit_req   zone=ip_second  burst=5  nodelay;</span><br><span class="line">    limit_req_zone $binary_remote_addr zone=ip_minute:100m   rate=10r/m;</span><br><span class="line">    limit_req   zone=ip_minute  burst=50  nodelay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HttpLimitReqModul为nginx官方自带的&lt;strong&gt;限制单位时间内请求次数&lt;/strong&gt;的功能模块，通过&lt;strong&gt;limit_req_zone&lt;/strong&gt;和&lt;strong&gt;limit_req&lt;/strong&gt;指令配合使用来达到限制。一旦对
      
    
    </summary>
    
      <category term="nginx" scheme="http://yoursite.com/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>

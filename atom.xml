<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李庭嘉的博客</title>
  
  <subtitle>工具谁都能用，掌握原理才是核心</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-03T11:21:15.448Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Do Lee</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python的with原理</title>
    <link href="http://yoursite.com/2018/11/30/Python%E7%9A%84with%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/11/30/Python的with原理/</id>
    <published>2018-11-30T04:26:41.000Z</published>
    <updated>2018-12-03T11:21:15.448Z</updated>
    
    <content type="html"><![CDATA[<h3 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h3><p>对一个文件进行操作，我们可以这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(file, mode)</span><br><span class="line">...</span><br><span class="line">f.close() #关闭文件</span><br></pre></td></tr></table></figure></p><p>但是可能会在文件操作的过程中触发异常，导致<code>f.close()</code>没有被执行，于是我们对其做出以下改良：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">f = open(file, mode)</span><br><span class="line">try:</span><br><span class="line">    ...</span><br><span class="line">finally:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure></p><p>嗯…貌似有点繁琐，能不能用一个简单点的方法呢？这时<code>with</code>就出现了：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with open(file, mode) as f:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><p>相当于用with包裹后，自动处理了文件的关闭。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>那具体是怎么实现的呢？<br>我们先来看看有关上下文管理器的概念：</p><ul><li><p>上下文管理协议（Context Management Protocol）</p><blockquote><p>包含方法 <strong>enter</strong>() 和 <strong>exit</strong>()，支持<br>该协议的对象要实现这两个方法。</p></blockquote></li><li><p>上下文管理器（Context Manager）</p><blockquote><p>支持上下文管理协议的对象，这种对象实现了<br><strong>enter</strong>() 和 <strong>exit</strong>() 方法。上下文管理器定义执行 with 语句时要建立的运行时上下文，<br>负责执行 with 语句块上下文中的进入与退出操作。通常使用 with 语句调用上下文管理器，<br>也可以通过直接调用其方法来使用。</p></blockquote></li><li><p>运行时上下文（runtime context）</p><blockquote><p>由上下文管理器创建，通过上下文管理器的 <strong>enter</strong>() 和<br><strong>exit</strong>() 方法实现，<strong>enter</strong>() 方法在语句体执行之前进入运行时上下文，<strong>exit</strong>() 在<br>语句体执行完后从运行时上下文退出。with 语句支持运行时上下文这一概念。</p></blockquote></li></ul><h3 id="with-语句执行过程"><a href="#with-语句执行过程" class="headerlink" title="with 语句执行过程"></a>with 语句执行过程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">context_manager = context_expression</span><br><span class="line">exit = type(context_manager).__exit__ </span><br><span class="line">value = type(context_manager).__enter__(context_manager)</span><br><span class="line">exc = True   # True 表示正常执行，即便有异常也忽略；False 表示重新抛出异常，需要对异常进行处理</span><br><span class="line">try:</span><br><span class="line">    try:</span><br><span class="line">        target = value  # 如果使用了 as 子句</span><br><span class="line">        with-body     # 执行 with-body</span><br><span class="line">    except:</span><br><span class="line">        # 执行过程中有异常发生</span><br><span class="line">        exc = False</span><br><span class="line">        # 如果 __exit__ 返回 True，则异常被忽略；如果返回 False，则重新抛出异常</span><br><span class="line">        # 由外层代码对异常进行处理</span><br><span class="line">        if not exit(context_manager, *sys.exc_info()):</span><br><span class="line">            raise</span><br><span class="line">finally:</span><br><span class="line">    # 正常退出，或者通过 statement-body 中的 break/continue/return 语句退出</span><br><span class="line">    # 或者忽略异常退出</span><br><span class="line">    if exc:</span><br><span class="line">        exit(context_manager, None, None, None)</span><br><span class="line">    # 缺省返回 None，None 在布尔上下文中看做是 False</span><br></pre></td></tr></table></figure><h3 id="自定义上下文管理器"><a href="#自定义上下文管理器" class="headerlink" title="自定义上下文管理器"></a>自定义上下文管理器</h3><p>现在试着自己实现一个上下文管理器，实现对文件资源的释放<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># 自行定義 Context Manager</span><br><span class="line">class File(object):</span><br><span class="line">  def __init__(self, filename, mode):</span><br><span class="line">    # 設定檔名與開檔模式</span><br><span class="line">    self.filename = filename</span><br><span class="line">    self.mode = mode</span><br><span class="line"></span><br><span class="line">  # 配給資源（開啟檔案）</span><br><span class="line">  def __enter__(self):</span><br><span class="line">    print(&quot;開啟檔案：&quot; + self.filename)</span><br><span class="line">    self.open_file = open(self.filename, self.mode)</span><br><span class="line">    return self.open_file</span><br><span class="line"></span><br><span class="line">  # 回收資源（關閉檔案）</span><br><span class="line">  def __exit__(self, type, value, traceback):</span><br><span class="line">    print(&quot;關閉檔案：&quot; + self.filename)</span><br><span class="line">    self.open_file.close()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with File(&quot;file.txt&quot;, &quot;w&quot;) as f:</span><br><span class="line">  print(&quot;寫入檔案...&quot;)</span><br><span class="line">  f.write(&quot;Hello, world.&quot;)</span><br></pre></td></tr></table></figure></p><p>另一种实现方式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#/usr/bin/python</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line">from contextlib import contextmanager</span><br><span class="line"></span><br><span class="line"># 自行定義 Context Manager</span><br><span class="line">@contextmanager</span><br><span class="line">def open_file(name, mode):</span><br><span class="line">  # 配給資源（開啟檔案）</span><br><span class="line">  f = open(name, mode)</span><br><span class="line">  yield f</span><br><span class="line">  # 回收資源（關閉檔案）</span><br><span class="line">  f.close()</span><br><span class="line"></span><br><span class="line">with open_file(&apos;file.txt&apos;, &apos;w&apos;) as f:</span><br><span class="line">  f.write(&quot;Hello, world.&quot;)</span><br></pre></td></tr></table></figure></p><h3 id="对with的总结"><a href="#对with的总结" class="headerlink" title="对with的总结"></a>对with的总结</h3><blockquote><p>with适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等。</p></blockquote><h3 id="nested-同时使用多个with嵌套"><a href="#nested-同时使用多个with嵌套" class="headerlink" title="nested 同时使用多个with嵌套"></a>nested 同时使用多个with嵌套</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">with nested(A(), B(), C()) as (X, Y, Z):</span><br><span class="line">     # with-body code here</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">with A() as X:</span><br><span class="line">    with B() as Y:</span><br><span class="line">        with C() as Z:</span><br><span class="line">             # with-body code here</span><br></pre></td></tr></table></figure><p>需要注意的是，发生异常后，如果某个上下文管理器的 <strong>exit</strong>() 方法对异常处理返回 False，则更外层的上下文管理器不会监测到异常。</p><p>参考</p><ul><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/opensource/os-cn-pythonwith/index.html</a></li><li><a href="https://blog.gtwang.org/programming/python-with-context-manager-tutorial/" target="_blank" rel="noopener">https://blog.gtwang.org/programming/python-with-context-manager-tutorial/</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h3&gt;&lt;p&gt;对一个文件进行操作，我们可以这样写：&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
      <category term="Python" scheme="http://yoursite.com/categories/Python/"/>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>nginx频率限制模块之HttpLimitReqModul</title>
    <link href="http://yoursite.com/2018/11/30/nginx%E9%A2%91%E7%8E%87%E9%99%90%E5%88%B6%E6%A8%A1%E5%9D%97%E4%B9%8BHttpLimitReqModul/"/>
    <id>http://yoursite.com/2018/11/30/nginx频率限制模块之HttpLimitReqModul/</id>
    <published>2018-11-30T04:26:41.000Z</published>
    <updated>2018-12-03T11:21:15.448Z</updated>
    
    <content type="html"><![CDATA[<p>HttpLimitReqModul为nginx官方自带的<strong>限制单位时间内请求次数</strong>的功能模块，通过<strong>limit_req_zone</strong>和<strong>limit_req</strong>指令配合使用来达到限制。一旦对应的累计连接超过指定数量，就会返回503错误。<br>可以利用该规则对IP和URL进行访问频率的限制。</p><blockquote><ul><li>limit_conn_zone 定义IP或url访问的频率限制规则<br>只能配置在 http{} </li><li>limit_conn 启用对应的规则<br>可以配置于http{}，server{}，location{} </li></ul></blockquote><h4 id="限制规则"><a href="#限制规则" class="headerlink" title="限制规则"></a>限制规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">limit_req_zone $binary_remote_addr zone=ip_second:10m   rate=10r/s;</span><br><span class="line">limit_req_zone $request_uri zone=url_minute:10m   rate=1r/m;</span><br></pre></td></tr></table></figure><ul><li>limit_req_zone 可以理解为命令声明，类似于 <code>int x=0</code> 中的 int<h5 id="限制类型"><a href="#限制类型" class="headerlink" title="限制类型"></a>限制类型</h5></li><li>$binary_remote_addr 代表限制IP</li><li>$request_uri 代表限制URL<h5 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h5></li><li><code>zone=ip_second:10m   rate=10r/s</code>相当于<code>zone=限制规则变量名:内存占用上限 频率=次数r/秒</code><h5 id="内存占用上限"><a href="#内存占用上限" class="headerlink" title="内存占用上限"></a>内存占用上限</h5></li><li>1m大约可以存1.6W个ip回话</li><li>10m—-16W<h5 id="频率限制"><a href="#频率限制" class="headerlink" title="频率限制"></a>频率限制</h5>采用漏桶原理，简单理解就是，<code>rate=10r/s</code> 这十个请求平均分配在1秒内，也就是100ms最多能通过一次请求，而不是前面100ms接收10次，后面才不能接收。</li></ul><h4 id="限制范围"><a href="#限制范围" class="headerlink" title="限制范围"></a>限制范围</h4><p>当 limit_req 设置后，对应的 limit_req_zone 规则才会生效，而且只在 limit_req 声明的范围内生效<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">limit_req   zone=限制规则变量名 burst=5  nodelay;</span><br></pre></td></tr></table></figure></p><h5 id="全局生效"><a href="#全局生效" class="headerlink" title="全局生效"></a>全局生效</h5><p>将此命令放在 http{} 层，紧接着 limit_req_zone 之后</p><h5 id="局部生效"><a href="#局部生效" class="headerlink" title="局部生效"></a>局部生效</h5><p>将此命令放在 server{} 或 location{} 层，则在此之外的层级不受影响，还可以在不同的层级设置不同的规则<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server&#123;</span><br><span class="line">limit_req   zone=限制规则变量名  burst=2  nodelay;</span><br><span class="line">&#125;</span><br><span class="line">server&#123;</span><br><span class="line">limit_req   zone=限制规则变量名  burst=5  nodelay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="burst"><a href="#burst" class="headerlink" title="burst"></a>burst</h5><p>burst 代表令牌数量，至少要为1，即可以在limit_req_zone规则的基础上，额外可以请求的数量。<br>令牌消耗后，以 limit_req_zone 定义的时间单位恢复。</p><h4 id="频率单位"><a href="#频率单位" class="headerlink" title="频率单位"></a>频率单位</h4><p>只能控制 秒（rate=100r/s） 和 分钟（rate=100r/m） 级别</p><h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p>多个限制时，只要有一个符合条件，就会触发限制</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">        #限制ip</span><br><span class="line">        limit_req_zone $binary_remote_addr zone=ip_second:10m   rate=10r/s;</span><br><span class="line">        limit_req   zone=ip_second  burst=5  nodelay;</span><br><span class="line">        limit_req_zone $binary_remote_addr zone=ip_minute:100m   rate=10r/m;</span><br><span class="line">        limit_req   zone=ip_minute  burst=50  nodelay;</span><br><span class="line"></span><br><span class="line">        #限制url</span><br><span class="line">        limit_req_zone $request_uri zone=url_minute:10m   rate=1r/m;</span><br><span class="line">        limit_req   zone=url_minute  burst=1  nodelay;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一秒内请求100次</p><blockquote><p>ab -n 100 -c 10 url</p></blockquote><p>只会有51个成功，<code>rate=10r/m</code>代表一分钟10个请求，系统会默认把这十个请求平均分配在60秒内，即6秒一个请求，所以1秒内，只能用掉这里的1个名额，剩下50个名额用的是<code>burst=50</code>令牌的名额。</p><h4 id="自定义返回码"><a href="#自定义返回码" class="headerlink" title="自定义返回码"></a>自定义返回码</h4><p>自定义限制规则生效后的返回码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">    limit_conn_status 503;</span><br><span class="line"></span><br><span class="line">    limit_req_zone $binary_remote_addr zone=ip_second:10m   rate=100r/s;</span><br><span class="line">    limit_req   zone=ip_second  burst=5  nodelay;</span><br><span class="line">    limit_req_zone $binary_remote_addr zone=ip_minute:100m   rate=10r/m;</span><br><span class="line">    limit_req   zone=ip_minute  burst=50  nodelay;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;HttpLimitReqModul为nginx官方自带的&lt;strong&gt;限制单位时间内请求次数&lt;/strong&gt;的功能模块，通过&lt;strong&gt;limit_req_zone&lt;/strong&gt;和&lt;strong&gt;limit_req&lt;/strong&gt;指令配合使用来达到限制。一旦对
      
    
    </summary>
    
      <category term="nginx" scheme="http://yoursite.com/categories/nginx/"/>
    
    
      <category term="nginx" scheme="http://yoursite.com/tags/nginx/"/>
    
      <category term="网络安全" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
